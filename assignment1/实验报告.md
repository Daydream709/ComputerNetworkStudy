# assignment1 套接字编程实验报告

## 实验目的

本次实验旨在学习和掌握套接字(Socket)编程的基本原理和技术，实现基于TCP协议的客户端-服务器通信程序。通过本实验，我们熟悉了网络编程的基础概念，掌握了如何使用套接字API创建网络应用程序，并实现了在不同编程语言(C和Python)下的客户端与服务器通信功能。

## 实验环境

- 操作系统：Ubuntu 14.04 (通过Vagrant虚拟机运行)
- 编程语言：C语言、Python
- 开发工具：GCC编译器、Emacs文本编辑器
- 网络协议：TCP/IP协议族

## 实验原理

### 套接字(Socket)简介

套接字(Socket)是一种通信机制，允许不同机器间的进程进行通信。它提供了应用层进程利用网络协议栈传递数据的编程接口。在本实验中，我们主要关注TCP流式套接字，它提供了一个可靠的、面向连接的数据传输服务。

### TCP通信流程

1. 服务器端：
   - 创建套接字
   - 绑定地址和端口
   - 监听连接请求
   - 接受客户端连接
   - 接收和处理数据
   - 关闭连接

2. 客户端：
   - 创建套接字
   - 连接服务器
   - 发送数据
   - 关闭连接

## 实验实现

### C语言版本实现

#### 服务器端(server-c.c)

```c
int server(char *server_port)
{
    int port = atoi(server_port);
    if (port <= 0)
    {
        fprintf(stderr, "Invalid port number\n");
        return 1;
    }

    // 注册信号处理器
    signal(SIGINT, signal_handler);

    // 创建socket
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
    {
        perror("socket");
        return 1;
    }

    // 设置socket选项，允许地址重用
    int yes = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)
    {
        perror("setsockopt");
        close(sockfd);
        return 1;
    }

    // 配置服务器地址信息
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY; // 监听所有接口
    server_addr.sin_port = htons(port);       // 端口号转换为网络字节序

    // 绑定地址和端口
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        perror("bind");
        close(sockfd);
        return 1;
    }

    // 开始监听连接
    if (listen(sockfd, QUEUE_LENGTH) < 0)
    {
        perror("listen");
        close(sockfd);
        return 1;
    }

    // 循环接受客户端连接
    while (1)
    {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);

        // 接受客户端连接
        int client_fd = accept(sockfd, (struct sockaddr *)&client_addr, &client_len);
        if (client_fd < 0)
        {
            perror("accept");
            continue; // 继续处理下一个连接请求
        }

        // 接收并处理客户端消息
        char buffer[RECV_BUFFER_SIZE];
        ssize_t bytes_received;

        while ((bytes_received = recv(client_fd, buffer, RECV_BUFFER_SIZE, 0)) > 0)
        {
            fwrite(buffer, 1, bytes_received, stdout);
            fflush(stdout);
        }

        // 处理接收错误（保持错误输出）
        if (bytes_received < 0)
        {
            perror("recv");
        }

        // 关闭客户端连接
        close(client_fd);
    }

    close(sockfd);
    return 0;
}
```

#### 客户端(client-c.c)

```c
int client(char *server_ip, char *server_port)
{
  int sockfd;
  struct sockaddr_in server_addr;
  char buffer[SEND_BUFFER_SIZE];
  ssize_t bytes_read;

  // 创建socket
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd < 0)
  {
    perror("socket");
    return 1;
  }

  // 配置服务器地址信息
  memset(&server_addr, 0, sizeof(server_addr));
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(atoi(server_port));

  // 将点分十进制IP地址转换为二进制格式
  if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0)
  {
    fprintf(stderr, "Invalid address/ Address not supported\n");
    close(sockfd);
    return 1;
  }

  // 连接到服务器
  if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
  {
    perror("connect");
    close(sockfd);
    return 1;
  }

  // 从标准输入读取数据并发送到服务器
  while ((bytes_read = read(STDIN_FILENO, buffer, SEND_BUFFER_SIZE)) > 0)
  {
    ssize_t total_bytes_sent = 0;

    // 循环发送直到所有数据都被发送出去
    while (total_bytes_sent < bytes_read)
    {
      ssize_t bytes_sent = send(sockfd, buffer + total_bytes_sent,
                                bytes_read - total_bytes_sent, 0);

      if (bytes_sent < 0)
      {
        perror("send");
        close(sockfd);
        return 1;
      }

      total_bytes_sent += bytes_sent;
    }
  }

  // 检查读取是否出错
  if (bytes_read < 0)
  {
    perror("read");
    close(sockfd);
    return 1;
  }

  // 关闭套接字
  close(sockfd);
  return 0;
}
```

### Python版本实现

#### 服务器端(server-python.py)

```python
def server(server_port):
    """Listen on socket and print received message to sys.stdout"""
    # 创建TCP套接字
    sockfd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        # 设置套接字选项，允许地址重用
        sockfd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        # 绑定地址和端口
        server_address = ("", server_port)
        sockfd.bind(server_address)

        # 开始监听连接
        sockfd.listen(QUEUE_LENGTH)

        while True:
            # 接受客户端连接
            client_fd, client_addr = sockfd.accept()

            try:
                # 接收并处理客户端消息
                while True:
                    data = client_fd.recv(RECV_BUFFER_SIZE)
                    if not data:
                        break

                    # 输出到标准输出
                    sys.stdout.buffer.write(data)
                    sys.stdout.flush()

            except Exception as e:
                print("Error receiving data: " + str(e))

            finally:
                # 关闭客户端连接
                client_fd.close()

    except Exception as e:
        print("Server error: " + str(e))

    finally:
        # 关闭服务器套接字
        sockfd.close()
```

#### 客户端(client-python.py)

```python
def client(server_ip, server_port):
    """Open socket and send message from sys.stdin"""
    # 创建TCP套接字
    sockfd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        # 连接到服务器
        server_address = (server_ip, server_port)
        sockfd.connect(server_address)

        # 从标准输入读取二进制数据并发送到服务器
        while True:
            data = sys.stdin.buffer.read(SEND_BUFFER_SIZE)
            if not data:
                break

            # 发送数据到服务器
            # 替换现有的发送逻辑
            while data:
                bytes_sent = sockfd.send(data)
                if bytes_sent < len(data):
                    # 如果只发送了部分数据，保存剩余数据并继续发送
                    data = data[bytes_sent:]
                else:
                    # 全部发送成功，跳出循环
                    break

    except Exception as e:
        print("Client error: " + str(e), file=sys.stderr)
        return 1

    finally:
        # 关闭套接字
        sockfd.close()

    return 0
```

## 功能特性

### 服务器功能
1. 在指定端口监听客户端连接
2. 支持多个客户端连接的顺序处理
3. 能够接收任意长度的消息
4. 正确处理连接错误和异常情况
5. 支持通过Ctrl+C优雅退出

### 客户端功能
1. 连接到指定IP地址和端口的服务器
2. 从标准输入读取消息并发送给服务器
3. 支持发送任意大小的消息
4. 处理部分发送的情况，确保所有数据都被发送
5. 正确关闭连接

## 测试验证

我们使用提供的测试脚本 [test_client_server.sh](file://d:\code\ComputerNetwork\assignment1\COS461-Public\assignments\assignment1\client_server\test_client_server.sh) 对实现进行了全面测试，包括：

1. 短消息测试："Go Tigers!\n"
2. 长随机字母数字消息测试
3. 长随机二进制消息测试
4. 服务器无限循环测试（多个顺序客户端）
5. 服务器队列测试（并发客户端）

测试涵盖了所有四种组合：
- C客户端与C服务器
- Python客户端与Python服务器
- C客户端与Python服务器
- Python客户端与C服务器

所有测试均通过，表明我们的实现在各种情况下都能正确工作。

## 遇到的问题及解决方案

1. **部分发送问题**：在网络编程中，一次send调用并不保证发送所有数据。解决方法是循环发送直到所有数据都已发送。
   
2. **地址重用问题**：服务器重启时可能会遇到"Address already in use"错误。通过设置SO_REUSEADDR套接字选项解决了这个问题。

3. **缓冲区刷新问题**：服务器需要及时输出收到的数据。通过在每次接收后调用fflush(stdout)确保数据立即显示。

4. **大消息处理**：对于大消息，不能一次性读入内存。通过分块读取和发送的方式处理任意大小的消息。

## 实验总结

通过本次实验，我们深入理解了TCP套接字编程的核心概念和实现技巧。我们学会了：

1. 如何使用套接字API建立TCP连接
2. 客户端和服务器的基本编程模式
3. 错误处理和异常情况的应对策略
4. 处理大数据量传输的技术
5. 不同编程语言下套接字编程的异同

实验过程中，我们不仅掌握了理论知识，还提高了实际编程能力和调试技巧。通过多种语言的实现对比，我们更加深刻地理解了套接字编程的本质和跨语言的一致性。

这次实验为我们今后进行更复杂的网络编程打下了坚实的基础，也让我们对计算机网络通信有了更直观的认识。